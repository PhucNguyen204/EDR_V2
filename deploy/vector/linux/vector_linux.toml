[sources.journald]
type = "journald"

[sources.auditd]
type = "file"
include = ["/var/log/audit/audit.log"]
ignore_older_secs = 0

[transforms.lnx_normalize]
type   = "remap"
inputs = ["journald", "auditd"]
source = '''
# Generic message for keyword rules
.Message = (.MESSAGE ?? .message ?? .msg ?? .MESSAGE_STR) ?? .Message

# If journald identifies bash/sh/ssh, map CommandLine from MESSAGE
if exists(.SYSLOG_IDENTIFIER) {
  id = downcase!(to_string!(.SYSLOG_IDENTIFIER))
  if contains(id, "bash") || contains(id, "sh") {
    .Image = .Image ?? "/bin/" + id
    .CommandLine = .CommandLine ?? to_string!(.Message)
  }
}

# Parse auditd lines for execve/syscall
if is_string(.) {
  line = .
  # exe path
  m = parse_regex!(line, /exe=\"(?P<exe>[^\"]+)\"/)
  if m != null { .Image = .Image ?? m.exe }
  # proctitle (cmdline)
  m2 = parse_regex!(line, /proctitle=\"(?P<pt>[^\"]+)\"/)
  if m2 != null { .CommandLine = .CommandLine ?? replace!(m2.pt, "\x00", " ") }
}
'''

[sinks.edr_http]
type = "http"
inputs = ["lnx_normalize"]
uri = "${EDR_SERVER_URL}"
method = "post"

[sinks.edr_http.encoding]
codec = "json"

[sinks.edr_http.request]
retry_max_duration_secs = 300

[sinks.edr_http.batch]
max_events = 1000
timeout_secs = 2

[sinks.edr_http.compression]
type = "gzip"
