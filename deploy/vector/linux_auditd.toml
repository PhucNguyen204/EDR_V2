# =======================
# Global
# =======================
data_dir = "/home/puckun/vector-data"

# =======================
# Sources
# =======================
[sources.audit_raw]
type = "file"
include = [ "./audit_test.log" ]
read_from = "beginning"

# =======================
# Transforms
# =======================
[transforms.audit_parsed]
type = "remap"
inputs = ["audit_raw"]
source = '''
  # The format is deceptively complex - it looks like key-value pairs but there's actually a few layers of nesting.
  # This parser is based on reverse-engineering auditd.
  # Each line is a key-value-pair string from the kernel, inserted by auditd into another key-value-pair string as an unquoted value.
  # Fortunately there is just enough context to yank out the kernel string from the auditd string and parse them separately.
  # The \x1d byte is AUDIT_INTERP_SEPERATOR. Auditd inserts this at the end of the kernel string and before the trailing "enrichment fields".
  match1 = parse_regex(.message, r'^(?P<auditd_prefix>.*)\bmsg=(?P<kernel>audit\(.*)\x1d(?P<auditd_suffix>.*)$') ?? {}
  . |= parse_key_value(match1.auditd_prefix) ?? {}
  . |= parse_key_value(match1.auditd_suffix) ?? {}
  kernel_message = match1.kernel || ""
  # The kernel message begins with the timestamp and a sequence number.
  match2 = parse_regex(kernel_message, r'^audit\((?P<timestamp>[0-9.]+):(?P<seqno>\d+)\):\s*(?P<rest>.*)$') ?? {}
  ._parsed_timestamp = parse_timestamp(match2.timestamp, "%s%.f") ?? null
  .timestamp = ._parsed_timestamp || now()
  .seqno = parse_int(match2.seqno, 10) ?? null
  kernel_message = match2.rest || kernel_message
  # The rest of the kernel message is a key-value-pair string; however it may contain _another_ embedded key-value-pair string as the value of the 'msg' key.
  # Fortunately this one is delimited by single quotes.
  # Unfortunately parse_key_value doesn't understand single quotes, so we have to yank this embedded string out with a regex.
  match3, err = parse_regex(kernel_message, r'^(?P<prefix>.*)\bmsg=\x27(?P<quoted>[^\x27]*)\x27(?P<suffix>.*)$')
  if err == null {
    . |= parse_key_value(match3.prefix) ?? {}
    . |= parse_key_value(match3.quoted) ?? {}
    . |= parse_key_value(match3.suffix) ?? {}
  } else {
    . |= parse_key_value(kernel_message) ?? {}
  }
'''

# =======================
# Sinks
# =======================
[sinks.audit_console]
type   = "console"
inputs = ["audit_parsed"]
target = "stdout"        # hoặc "stderr" nếu bạn muốn
encoding.codec = "json"

# (tuỳ chọn) Bật API healthcheck nếu bạn muốn kiểm tra /metrics
# [api]
# enabled = true
# address = "127.0.0.1:8686"
